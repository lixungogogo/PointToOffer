#define _CRT_SECURE_NO_WARNINGS 1
#include <iostream>
#include <assert.h>
using namespace std;

/*****************************************************
题目描述：请实现一个函数，输入一个整数，输出该数二进制表示中
		 1的个数。
思路分析：1.判断整数二进制最右边的数是不是1，然后再右移循环
		 上面这个思路需要注意当输入数字是一个负数的时候，每次
		 右移会给最高位赋1，所以最后数字会变成0XFFF..F，造成
		 死循环
		 2.先判断最低位是不是1，再让1左移一位变成2，判断第二位
		 是不是1，再左移2，...反复左移，每次都能判断其中那一位
		 是不是1.
		 第二种思路整数二进制有几位就需要循环几次。
		 3.把一个整数减去一，再和原整数做与运算，会把该整数最右
		 边的一个1变成0.那么一个整数二进制中有多少个1，就能进行
		 多少次这种操作
解法分析：思路三是最高效最全面的解法
特殊测试：1.正数，包括边界值1，0X7FFFFFFF
		 2.负数，包括边界值0X80000000，0XFFFFFFFF
		 3.0
*********************************************************/

//解法一：最容易想到但是如果输入的是一个负数会导致死循环
int NumOfOne1(int num)
{
	int icount = 0;
	while (num)
	{
		if (num & 1)
			icount++;
		num >>= 1;//除2和右移一位效果相同，但是移位运算更加高效
	}
	return icount;
}
//解法二，能够解决输入负数导致的死循环，但是循环次数较多，效率不高
int NumOfOne2(int num)
{
	int icount = 0;
	size_t flag = 1;//防止输入负数导致的死循环
	while (flag)
	{
		if (num & flag)
			icount++;
		flag <<= 1;
	}
	return icount;
}

//解法三，数字二进制中有几个1就循环几次
//算法思路：把一个整数减去一，再和原整数做与运算，会把该整数最右边的一个1变成0.
//那么一个整数二进制中有多少个1，就能进行多少次这种操作
int NumOfOne3(int num)
{
	int icount = 0;
	while (num)
	{
		icount++;
		num = num &(num - 1);
	}
	return icount;
}
